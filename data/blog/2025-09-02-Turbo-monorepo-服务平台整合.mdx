---
title: '用 Turborepo 整合服务平台前后台：Monorepo 的落地细节'
date: '2025-09-02'
tags: ['Monorepo', 'Turborepo', '工程化']
draft: false
summary: '记录如何把服务平台的后台（Umi/Ant Design Pro）与前台（React + Vite）迁入 Turborepo，完整梳理 subtree 引入、依赖治理、构建编排与注意事项。'
---

为了把 Ant Design Pro（Umi Max）后台与 React + Vite 服务前台整合到同一个 Turborepo，我把原目录配置梳理成一份可复用的迁移清单。本文聚焦多项目迁移的完整流程：前期盘点、subtree 引入与验证、依赖治理、Turborepo 配置、共享包管理以及最终去除子仓库 git 记录，落地一个全新的 monorepo。

## 1. 初始盘点与目标

- **现状**：Umi Max 管理后台与 React + Vite 服务前台是两个纯前端仓库，脚本与依赖完全分离，无法就地共享类型/工具。
- **目标**：统一依赖治理与脚本出口，沉淀共享包，构建一条 Turborepo 流水线，并确保两个应用依旧可以独立发布。
- **约束**：迁移过程中要确保与同事对齐历史版本，确认代码在 monorepo 中正常运行，再逐步移除原子仓库的 git 记录，最终只保留新的 monorepo 仓库。

## 2. Monorepo 骨架（整合目录）

```bash
th-monorepo/
├── apps/
│   ├── service-platform-fe/    # React + Vite 服务前台
│   └── backend-web/            # Umi/Ant Design Pro 管理后台
├── packages/
│   ├── shared-types/          # API/实体类型
│   ├── shared-utils/          # 通用工具函数
│   └── shared-ui/             # （计划）可复用组件
├── package.json
├── pnpm-workspace.yaml
├── turbo.json
├── tsconfig.base.json
└── README.md
```

**整合动作**：

1. 使用 `git subtree add --prefix=apps/<app>` 把两个历史仓库拉入新仓库，确保 commit 可追溯。
2. 与原项目负责人确认迁入版本，完成一次联调验证（`pnpm --filter <app> dev`）。
3. 验证通过后，删除原子仓库的 `.git` 目录和远程引用，在公司 Git 平台上创建新的主仓库，仅保留 Turborepo 版本。
4. 在 README 中记录 subtree 同步、验证步骤与新仓库的协作方式，方便后续检查历史或必要时再次同步。

## 3. pnpm 工作区与 TypeScript 配置

`pnpm-workspace.yaml`：

```yaml
packages:
  - 'apps/*'
  - 'packages/*'
```

`package.json`（核心片段）：

```json
{
  "name": "th-monorepo",
  "private": true,
  "packageManager": "pnpm@10",
  "scripts": {
    "dev": "pnpm turbo run dev --parallel",
    "dev:frontend": "pnpm --filter service-platform-fe dev",
    "dev:backend": "pnpm --filter backend-web dev",
    "build": "pnpm turbo run build",
    "lint": "pnpm turbo run lint",
    "type-check": "pnpm turbo run type-check"
  },
  "devDependencies": {
    "turbo": "^2.0.0",
    "typescript": "^5.5.0",
    "@types/node": "^22.0.0"
  }
}
```

`tsconfig.base.json` 统一路径别名与严格模式，示例：

```json
{
  "compilerOptions": {
    "strict": true,
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "baseUrl": ".",
    "paths": {
      "@th/shared-types": ["packages/shared-types/src"],
      "@th/shared-utils": ["packages/shared-utils/src"]
    }
  },
  "exclude": ["node_modules", "dist"]
}
```

## 4. Turborepo Pipeline（构建/测试/开发）

```json
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**", "build/**"]
    },
    "lint": {
      "dependsOn": ["^lint"]
    },
    "type-check": {
      "dependsOn": ["^type-check"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    }
  }
}
```

实践要点：

- `dependsOn: ["^build"]` 让共享包先构建，避免 Vite/Umi 在消费时找不到产物。
- Vite 与 Umi 的 dev 命令都设置 `cache: false`，防止 Turborepo 缓存干扰热更新。
- CI 使用 `pnpm turbo run lint test build --filter=...` 自动推导最小执行集，减少无意义的重复构建。

## 5. 共享包与依赖治理

- `@th/shared-types`：集中 API Response、分页、菜单、权限、枚举等，Umi/Vite 都以 `workspace:*` 引用，类型修改立即生效。
- `@th/shared-utils`：封装存储、加密、日期、验证、数组、对象、字符串、数字、URL、文件等工具；在 Node 环境才需要的能力拆分子模块导出，避免被 Vite/Ant Design Pro 客户端 bundle。
- 规划 `@th/shared-ui` 与 `@th/shared-config`，前者沉淀通用 React 组件，后者管理环境变量/feature flag。

依赖治理策略：

1. 通用依赖（React、TypeScript、lint 工具等）上移至根 `package.json`，保持版本锁定。
2. 子应用仅声明特有依赖（如 `@umijs/max`、`vite`、`@vitejs/plugin-react`），通过 `pnpm install --filter <app>` 维护，自带作用域隔离。
3. 所有内部包都用 `workspace:*`，避免手动升级版本或意外发布到 npm。
4. 约定新增包时同步更新 `pnpm-workspace.yaml` 和 Turborepo pipeline，确保依赖拓扑正确。

## 6. 权限与环境隔离

- **环境变量**：`apps/backend-web/.env.*` 与 `apps/service-platform-fe/.env.*` 各自维护，后台通过 Umi 内置配置加载，前台用 Vite `import.meta.env`；敏感变量一律只在 Server Side 注入，避免在共享包中硬编码。
- **API 代理**：Vite 本地开发使用 `server.proxy` 透传到后台 API，线上仍然是两个独立域名，只在 CI/CD 与共享包层面耦合。
- **操作权限**：借助 `pnpm filter` + `turbo --filter` 控制命令执行范围，例如后端专属脚本 `pnpm --filter backend-web lint`，避免误操作影响另一侧。
- **Git 管理**：subtree 引入后要与团队确认最终版本，迁移完成后移除子项目 `.git` 相关文件，确保主仓库成为唯一可信来源。

## 7. CI/CD 与验证流程

1. `pnpm install --frozen-lockfile`
2. `pnpm turbo run lint type-check --filter=...`
3. `pnpm turbo run build --filter=@th/*`
4. `pnpm turbo run build --filter=service-platform-fe`
5. `pnpm turbo run build --filter=backend-web`
6. 与同事核对构建产物与旧仓库比对（hash / 关键页面预览），确认无回归后再 cutover。

构建产物：

- Vite 前台输出到 `dist`/`build`，可直接上传 OSS/CDN。
- Umi 后台输出 `dist`，配合 Nginx/容器部署，与旧仓库保持一致，便于灰度对比。

## 8. 验收清单

> 1. `pnpm install`、`pnpm dev` 能在任意环境直接启动两个前端项目。  
> 2. `pnpm turbo run build --filter=@th/*` 可稳定输出共享包，并被 Vite/Umi 引用。  
> 3. `pnpm turbo run build --filter=service-platform-fe` 与 `--filter=backend-web` 的产物与旧仓库一致，必要时可对比 hash。  
> 4. README 记录了 workspace 结构、脚本别名、subtree 引入/移除流程。  
> 5. 新同事按照 README + 本文即可完成环境搭建、共享包引用与 CI 验证。  
> 6. 出现缓存异常可执行 `pnpm turbo run build --force` 清理，或删除 `.turbo` 目录重新生成。

## 结语

通过 Turborepo + pnpm，把 Umi/Ant Design Pro 后台与 React + Vite 前台迁移到 monorepo 的关键，在于：先用 subtree 精准引入并验证、再统一依赖与配置、最后去除旧仓库绑定。流程一旦沉淀，新项目或共享包的加入都会变成简单的模板化动作，协作效率和交付稳定性也随之提升。
