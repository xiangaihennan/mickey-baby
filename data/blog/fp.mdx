---
title: 函数式编程学习
date: '2021-2-10'
tags: ['fp', '函数式编程']
draft: false
summary: '函数式编程'
---

<TOCInline toc={props.toc} exclude="Overview" asDisclosure />

<br />

# 直观的概念

看了好多文章对函数式编程都没有一个准确的说法。

函数式和过程式的区别是思维方式，而不在于语法。

函数式的思维在于抽象流程，过程式的思维在于抽象主体。

简单说就是：谁干什么。 面相对象要抽象的是“谁”这个主体，而函数式要抽象的是“干什么”。

函数式编程是一种"编程范式"（programming paradigm），也就是如何编写程序的方法论。

# 特性

- 闭包和高阶函数
  函数编程支持函数作为第一类对象，有时称为闭包或者仿函数（functor）对象。实质上，闭包是起函数的作用并可以像对象一样操作的对象。与此类似，FP 语言支持高阶函数。高阶函数可以用另一个函数（间接地，用一个表达式） 作为其输入参数，在某些情况下，它甚至返回一个函数作为其输出参数。这两种结构结合在一起使得可以用优雅的方式进行模块化编程，这是使用 FP 的最大好处。 [4]
- 惰性计算
  除了高阶函数和仿函数（或闭包）的概念，FP 还引入了惰性计算的概念。在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。延迟的计算使您可以编写可能潜在地生成无穷输出的函数。因为不会计算多于程序的其余部分所需要的值，所以不需要担心由无穷计算所导致的 out-of-memory 错误。一个惰性计算的例子是生成无穷 Fibonacci 列表的函数，但是对第 n 个 Fibonacci 数的计算相当于只是从可能的无穷列表中提取一项。
- 递归
  FP 还有一个特点是用递归做为控制流程的机制。例如，Lisp 处理的列表定义为在头元素后面有子列表，这种表示法使得它自己自然地对更小的子列表不断递归。
- 函数式编程具有五个鲜明的特点。
- 函数是"第一等公民"
  所谓"第一等公民"（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。
  举例来说，下面代码中的 print 变量就是一个函数，可以作为另一个函数的参数。

```:js
var print = function(i){ console.log(i);};
[1,2,3].forEach(print);
```

- 只用"表达式"，不用"语句"
  "表达式"（expression）是一个单纯的运算过程，总是有返回值；"语句"（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。
  原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。"语句"属于对系统的读写操作，所以就被排斥在外。
  当然，实际应用中，不做 I/O 是不可能的。因此，编程过程中，函数式编程只要求把 I/O 限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。
- 没有"副作用"
  所谓"副作用"（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。
  函数式编程强调没有"副作用"，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。
- 不修改状态
  上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。
  在其他类型的语言中，变量往往用来保存"状态"（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。下面的代码是一个将字符串逆序排列的函数，它演示了不同的参数如何决定了运算所处的"状态"。
- 引用透明性
  函数程序通常还加强引用透明性，即如果提供同样的输入，那么函数总是返回同样的结果。就是说，表达式的值不依赖于可以改变值的全局状态。这使您可以从形式上推断程序行为，因为表达式的意义只取决于其子表达式而不是计算顺序或者其他表达式的副作用。这有助于验证正确性、简化算法，甚至有助于找出优化它的方法。
- 副作用
  副作用是修改系统状态的语言结构。因为 FP 语言不包含任何赋值语句，变量值一旦被指派就永远不会改变。而且，调用函数只会计算出结果 ── 不会出现其他效果。因此，FP 语言没有副作用。 [5]

```js:
/**
    1.编写的函数一定要是“纯函数”。（函数执行后不影响上下文 保证输入值返回值即可）
    2.功能指责尽量单一，一个函数只做一件事。
    3.要currying 更直观 接受一个值返回一个值，对于讨论和优化会更直观；并且有利于compose函数组合。
    4.遵循范畴模型，当前结果 -> 下一个结果 -> 下一个结果 -> 最终结果 （管道模型）
*/
const map = (fn) => (input) => input.map(fn)

const itemDouble = (x) => x \* 2

const f = map(itemDouble)([1, 2, 3, 4, 5, 5])
// 抽象获取 dom 元素
const getDom = (x) => document.querySelector(x)
const callbackDom = getDom(".callback")
// 抽象常规的事件 bind 函数
handlerPipe = (dom) => (type) => (fn) => (dom[`on${type}`] = fn) || dom.addEventListener(type, fn)
const func = ev => console.log(ev)
handlerPipe(callbackDom)("click")(func)
```

# 相关学习链接

- [函数式入门](https://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html '阮老师')

- [函数式编程指北～](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90 '书')
